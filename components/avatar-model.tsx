/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useMemo } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import * as THREE from "three";

interface AvatarModelProps {
  isSpeaking: boolean;
  isDigesting?: boolean;
}

export default function AvatarModel({ isSpeaking, isDigesting }: AvatarModelProps) {
  const group = useRef<THREE.Group>(null);
  const { scene } = useGLTF("/robo_face.glb");
  const clone = useMemo(() => scene.clone(), [scene]);

  const mouse = useRef({ x: 0, y: 0 });

  useEffect(() => {
    const handleMouseMove = (event: MouseEvent) => {
      // Normalize mouse position to -1 to 1
      mouse.current.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.current.y = -(event.clientY / window.innerHeight) * 2 + 1;
    };

    window.addEventListener("mousemove", handleMouseMove);
    return () => window.removeEventListener("mousemove", handleMouseMove);
  }, []);

  // Animation Logic
  useFrame((state) => {
    if (!group.current) return;
    
    const t = state.clock.getElapsedTime();
    
    // Idle floating
    const BASE_Y = -0.6;
    group.current.position.y = Math.sin(t * 1) * 0.1 + BASE_Y; // Bobbing slightly around BASE_Y

    const BASE_SCALE = 3.9;
    
    // Speaking Animation (Squash & Stretch)
    if (isSpeaking) {
        // Fast wobbling/scaling to simulate talking
        const speechScale = 1 + Math.sin(t * 20) * 0.05;
        group.current.scale.set(BASE_SCALE, BASE_SCALE * speechScale, BASE_SCALE);
    } else {
        // Return to normal scale
        group.current.scale.lerp(new THREE.Vector3(BASE_SCALE, BASE_SCALE, BASE_SCALE), 0.1);
    }

    // Digesting Animation (Spinning & Glowing effect potentially)
    if (isDigesting) {
        group.current.rotation.y += 0.1; // Fast spin
        // Add a "wobble" in rotation Z for chaos
        group.current.rotation.z = Math.sin(t * 15) * 0.1;
    } else {
        // Mouse follow logic (Global)
        const targetRotY = mouse.current.x * 0.4; // Look left/right (reduced slightly)
        
        // Clamp up/down looking to avoid "leaving frame" when looking down
        // mouse.current.y is -1 (bottom) to 1 (top)
        // We want to limit looking down (positive X rotation for the model usually)
        // Let's map -1..1 to a safe range like -0.1..0.2
        const safeY = Math.max(-0.5, Math.min(0.5, mouse.current.y));
        const targetRotX = safeY * 0.3; 

        group.current.rotation.y = THREE.MathUtils.lerp(group.current.rotation.y, targetRotY, 0.1);
        group.current.rotation.x = THREE.MathUtils.lerp(group.current.rotation.x, targetRotX, 0.1);
        group.current.rotation.z = THREE.MathUtils.lerp(group.current.rotation.z, 0, 0.1); // Reset Z wobble
    }
  });

  return (
    <group ref={group} dispose={null} position={[0, -0.6, 0]} scale={3.9}>
      <primitive object={clone} />
    </group>
  );
}

useGLTF.preload("/robo_face.glb");
